<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bazy Danych - Turbo Quiz (Random)</title>
    <style>
        :root {
            --bg-color: #121212;
            --container-bg: #1e1e1e;
            --text-main: #e0e0e0;
            --text-muted: #a0a0a0;
            --accent-blue: #375a7f;
            --accent-blue-hover: #2b4764;
            --correct-bg: #1b5e20;
            --correct-border: #2ecc71;
            --wrong-bg: #b71c1c;
            --wrong-border: #ff5252;
            --btn-bg: #2d2d2d;
            --btn-hover: #383838;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .quiz-container {
            background: var(--container-bg);
            width: 100%;
            max-width: 800px;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid #333;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        .score-board {
            font-size: 1.1em;
            font-weight: bold;
            display: flex;
            gap: 15px;
        }

        .score-item { display: flex; align-items: center; gap: 5px; }
        .score-correct { color: #2ecc71; }
        .score-wrong { color: #ff5252; }

        .question-text {
            font-size: 1.4em;
            margin-bottom: 30px;
            font-weight: 500;
            line-height: 1.4;
            color: #ffffff;
        }

        .options { display: flex; flex-direction: column; gap: 12px; }

        .option-btn {
            padding: 18px 20px;
            border: 2px solid #333;
            border-radius: 10px;
            background: var(--btn-bg);
            color: var(--text-main);
            cursor: pointer;
            font-size: 1rem;
            text-align: left;
            transition: all 0.2s ease;
            position: relative;
        }

        .option-btn:hover:not(:disabled) {
            background-color: var(--btn-hover);
            border-color: var(--accent-blue);
            transform: translateY(-2px);
        }

        .option-btn:disabled { cursor: default; opacity: 0.9; }

        /* Style po sprawdzeniu odpowiedzi */
        .option-btn.correct {
            background-color: rgba(46, 204, 113, 0.15);
            border-color: var(--correct-border);
            color: #fff;
        }
        
        .option-btn.wrong {
            background-color: rgba(255, 82, 82, 0.15);
            border-color: var(--wrong-border);
            color: #ffcccc;
        }

        /* Marker A, B, C, D */
        .opt-letter {
            font-weight: bold;
            margin-right: 10px;
            color: var(--accent-blue);
        }
        .correct .opt-letter { color: var(--correct-border); }
        .wrong .opt-letter { color: var(--wrong-border); }

        .explanation {
            margin-top: 25px;
            padding: 20px;
            border-radius: 8px;
            display: none;
            line-height: 1.5;
            background-color: #252526;
            border-left: 5px solid #555;
        }
        
        .explanation.visible { display: block; animation: fadeIn 0.3s; }
        .explanation.success { border-color: var(--correct-border); background-color: rgba(46, 204, 113, 0.05); }
        .explanation.error { border-color: var(--wrong-border); background-color: rgba(255, 82, 82, 0.05); }

        .nav-buttons {
            margin-top: 30px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #333;
            padding-top: 20px;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            background-color: var(--accent-blue);
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn:hover:not(:disabled) { background-color: var(--accent-blue-hover); }
        .btn:disabled { background-color: #333; color: #555; cursor: not-allowed; }

        /* Podsumowanie */
        .summary-view { text-align: center; }
        .summary-list { text-align: left; margin-top: 30px; max-height: 500px; overflow-y: auto; padding-right: 10px; }
        .review-item { 
            background: #252525; 
            margin-bottom: 10px; 
            padding: 15px; 
            border-radius: 8px; 
            border-left: 4px solid #555; 
        }
        .review-item.good { border-color: var(--correct-border); }
        .review-item.bad { border-color: var(--wrong-border); }
        
        .review-q { font-weight: bold; margin-bottom: 8px; display: block; }
        .review-ans { font-size: 0.9em; color: var(--text-muted); }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<div class="quiz-container" id="quiz-box">
    <div class="header">
        <div id="progress">Inicjalizacja...</div>
        <div class="score-board">
            <div class="score-item score-correct">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                <span id="correct-count">0</span>
            </div>
            <div class="score-item score-wrong">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                <span id="wrong-count">0</span>
            </div>
        </div>
    </div>

    <div id="question-area">
        <div class="question-text" id="question-text">Pobieranie pyta≈Ñ...</div>
        <div class="options" id="options-container"></div>
        <div class="explanation" id="explanation"></div>
    </div>

    <div class="nav-buttons">
        <button class="btn" id="prev-btn" onclick="prevQuestion()" disabled>Poprzednie</button>
        <button class="btn" id="next-btn" onclick="nextQuestion()" disabled>Nastƒôpne</button>
    </div>
</div>

<script>
// --- BAZA PYTA≈É ---
// Uwaga: W bazie "correct: 0" oznacza, ≈ºe pierwsza opcja jest poprawna.
// Skrypt poni≈ºej automatycznie to pomiesza przy starcie.
const questions = [
    {
        q: "Tabela jest w 2. Postaci Normalnej (2NF) wtedy i tylko wtedy, gdy jest w 1NF oraz:",
        options: [
            "Ka≈ºdy atrybut niekluczowy zale≈ºy od ca≈Ço≈õci klucza podstawowego (eliminuje zale≈ºno≈õƒá od czƒô≈õci klucza).",
            "Nie zawiera powtarzajƒÖcych siƒô rekord√≥w.",
            "Nie wystƒôpujƒÖ zale≈ºno≈õci przechodnie.",
            "Wszystkie pola zawierajƒÖ warto≈õci atomowe."
        ],
        correct: 0,
        desc: "2NF wymaga, aby ka≈ºdy atrybut niekluczowy zale≈ºa≈Ç od ca≈Çego klucza podstawowego. Je≈õli zale≈ºy tylko od czƒô≈õci klucza (w kluczach z≈Ço≈ºonych), tabela nie jest w 2NF."
    },
    {
        q: "Co oznacza 'Atomowo≈õƒá' (Atomicity) w modelu ACID?",
        options: [
            "Transakcja wykonuje siƒô w ca≈Ço≈õci albo wcale ('wszystko albo nic').",
            "Transakcja jest niewidoczna dla innych.",
            "Dane sƒÖ trwale zapisane po awarii.",
            "Baza jest sp√≥jna przed i po transakcji."
        ],
        correct: 0,
        desc: "Atomowo≈õƒá gwarantuje, ≈ºe transakcja jest niepodzielna. Je≈õli padnie jedna instrukcja, cofane sƒÖ wszystkie."
    },
    {
        q: "Kt√≥re zjawisko mo≈ºe wystƒÖpiƒá przy poziomie izolacji READ COMMITTED?",
        options: [
            "Non-repeatable reads (niepowtarzalny odczyt) oraz Phantom reads.",
            "Dirty reads (brudny odczyt).",
            "≈ªadne, to najbezpieczniejszy poziom.",
            "Utrata danych."
        ],
        correct: 0,
        desc: "READ COMMITTED zapobiega brudnym odczytom, ale wciƒÖ≈º mogƒÖ wystƒÖpiƒá niepowtarzalne odczyty (gdy kto≈õ zmieni dane w trakcie naszej transakcji) i fantomy."
    },
    {
        q: "3. Postaƒá Normalna (3NF) eliminuje:",
        options: [
            "Zale≈ºno≈õci przechodnie (atrybut niekluczowy zale≈ºy od innego atrybutu niekluczowego).",
            "Zale≈ºno≈õci od czƒô≈õci klucza.",
            "Grupy powtarzalne.",
            "Zale≈ºno≈õci wielowarto≈õciowe."
        ],
        correct: 0,
        desc: "3NF m√≥wi: ka≈ºdy atrybut niekluczowy musi zale≈ºeƒá TYLKO od klucza (nic o kluczu, ca≈Ça prawda o kluczu i tylko o kluczu)."
    },
    {
        q: "Instrukcja `ROLLBACK` s≈Çu≈ºy do:",
        options: [
            "Wycofania transakcji i przywr√≥cenia stanu sprzed jej rozpoczƒôcia.",
            "Zatwierdzenia zmian.",
            "Utworzenia kopii zapasowej.",
            "Usuniƒôcia tabeli."
        ],
        correct: 0,
        desc: "ROLLBACK cofa wszystkie operacje wykonane w ramach bie≈ºƒÖcej transakcji."
    },
    {
        q: "G≈Ç√≥wna cecha baz NoSQL (np. dokumentowych) to:",
        options: [
            "Brak sztywnego schematu (schema-less) - rekordy mogƒÖ mieƒá r√≥≈ºnƒÖ strukturƒô.",
            "Wym√≥g ≈õcis≈Çej normalizacji.",
            "Stosowanie wy≈ÇƒÖcznie jƒôzyka SQL.",
            "Brak mo≈ºliwo≈õci skalowania."
        ],
        correct: 0,
        desc: "Bazy NoSQL pozwalajƒÖ na elastyczno≈õƒá struktur danych (np. JSON), gdzie ka≈ºdy dokument mo≈ºe mieƒá inne pola."
    },
    {
        q: "Problem 'wiatraka' (Fan Trap) wystƒôpuje gdy:",
        options: [
            "Encja nadrzƒôdna ≈ÇƒÖczy siƒô z dwiema podrzƒôdnymi (1:N), kt√≥re nie sƒÖ po≈ÇƒÖczone ze sobƒÖ, gubiƒÖc sens powiƒÖzania miƒôdzy nimi.",
            "Wystƒôpuje pƒôtla w relacjach.",
            "Brakuje relacji w modelu.",
            "Klucz obcy jest pusty."
        ],
        correct: 0,
        desc: "Problem wiatraka prowadzi do dwuznaczno≈õci, bo nie wiemy, kt√≥ry element z grupy A pasuje do elementu z grupy B, mimo ≈ºe oba ≈ÇƒÖczƒÖ siƒô z C."
    },
    {
        q: "Regu≈Ça usuwania `SET NULL` w relacji oznacza, ≈ºe po usuniƒôciu rodzica:",
        options: [
            "W rekordach podrzƒôdnych klucz obcy zmieni siƒô na NULL (od≈ÇƒÖczenie).",
            "Rekordy podrzƒôdne zostanƒÖ usuniƒôte.",
            "Baza zablokuje usuwanie.",
            "Warto≈õƒá zmieni siƒô na 0."
        ],
        correct: 0,
        desc: "SET NULL powoduje, ≈ºe 'dzieci' tracƒÖ powiƒÖzanie z usuniƒôtym 'rodzicem', ale pozostajƒÖ w bazie jako rekordy osierocone (z NULL)."
    },
    {
        q: "Relacjƒô N:M (wiele do wielu) realizujemy fizycznie przez:",
        options: [
            "Tabelƒô ≈ÇƒÖczƒÖcƒÖ (po≈õredniƒÖ) z dwoma kluczami obcymi.",
            "Dodanie tablicy do kolumny.",
            "Dwa klucze obce w jednej tabeli.",
            "Klucz obcy w obu tabelach nawzajem."
        ],
        correct: 0,
        desc: "W bazach relacyjnych nie da siƒô zrobiƒá bezpo≈õredniego N:M. Tworzy siƒô tabelƒô '≈õrodkowƒÖ', kt√≥ra rozbija to na dwie relacje 1:N."
    },
    {
        q: "Klucz kandydujƒÖcy to:",
        options: [
            "Ka≈ºdy unikalny zestaw atrybut√≥w, kt√≥ry m√≥g≈Çby potencjalnie zostaƒá kluczem g≈Ç√≥wnym.",
            "Tylko klucz sztuczny.",
            "Klucz obcy.",
            "Pole z warto≈õciami NULL."
        ],
        correct: 0,
        desc: "Tabela mo≈ºe mieƒá kilka unikalnych identyfikator√≥w (np. PESEL i NIP). Oba sƒÖ kandydujƒÖce. Jeden wybieramy na Primary Key."
    },
    {
        q: "Zmiana struktury tabeli (np. dodanie kolumny) to polecenie:",
        options: [
            "ALTER TABLE",
            "UPDATE TABLE",
            "CHANGE TABLE",
            "MODIFY STRUCTURE"
        ],
        correct: 0,
        desc: "ALTER TABLE to instrukcja DDL s≈Çu≈ºƒÖca do modyfikacji schematu (dodawanie/usuwanie kolumn, constraint√≥w)."
    },
    {
        q: "TRUNCATE TABLE r√≥≈ºni siƒô od DELETE tym, ≈ºe:",
        options: [
            "Jest szybsze (DDL), usuwa wszystko, resetuje ID i nie u≈ºywa WHERE.",
            "Pozwala usunƒÖƒá wybrane wiersze.",
            "Mo≈ºna je cofnƒÖƒá w ka≈ºdej bazie bez transakcji.",
            "Usuwa samƒÖ definicjƒô tabeli."
        ],
        correct: 0,
        desc: "TRUNCATE czy≈õci tabelƒô b≈Çyskawicznie (zwalnia strony danych), ale jest bardziej restrykcyjne (brak WHERE)."
    },
    {
        q: "`DROP TABLE` powoduje:",
        options: [
            "Ca≈Çkowite usuniƒôcie tabeli (danych i struktury) z bazy.",
            "Usuniƒôcie tylko danych.",
            "Ukrycie tabeli.",
            "Wy≈ÇƒÖczenie kluczy."
        ],
        correct: 0,
        desc: "DROP to 'zrzucenie' obiektu. Tabela przestaje istnieƒá."
    },
    {
        q: "Kolejno≈õƒá logiczna wykonywania zapyta≈Ñ SQL to:",
        options: [
            "FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY",
            "SELECT -> FROM -> WHERE -> ORDER BY",
            "FROM -> SELECT -> WHERE -> GROUP BY",
            "SELECT -> WHERE -> GROUP BY"
        ],
        correct: 0,
        desc: "To kluczowe! Najpierw baza bierze tabelƒô (FROM), filtruje wiersze (WHERE), grupuje (GROUP), filtruje grupy (HAVING), wycina kolumny (SELECT) i sortuje (ORDER)."
    },
    {
        q: "`CROSS JOIN` zwraca:",
        options: [
            "Iloczyn kartezja≈Ñski (ka≈ºdy z ka≈ºdym).",
            "Czƒô≈õƒá wsp√≥lnƒÖ.",
            "Sumƒô zbior√≥w.",
            "Tylko pasujƒÖce wiersze."
        ],
        correct: 0,
        desc: "Je≈õli tabela A ma 10 wierszy, a B ma 10, CROSS JOIN zwr√≥ci 100 wierszy (wszystkie mo≈ºliwe pary)."
    },
    {
        q: "`LEFT JOIN` zwraca:",
        options: [
            "Wszystkie wiersze z lewej tabeli i dopasowane z prawej (NULL je≈õli brak).",
            "Tylko dopasowane wiersze.",
            "Wszystkie z prawej tabeli.",
            "Wszystkie z obu tabel."
        ],
        correct: 0,
        desc: "LEFT JOIN gwarantuje obecno≈õƒá rekord√≥w z lewej strony z≈ÇƒÖczenia, nawet jak nie majƒÖ pary."
    },
    {
        q: "Operator `APPLY` (T-SQL) pozwala na:",
        options: [
            "Z≈ÇƒÖczenie tabeli z funkcjƒÖ zwracajƒÖcƒÖ tabelƒô (uruchamianƒÖ dla ka≈ºdego wiersza).",
            "Szybsze sortowanie.",
            "≈ÅƒÖczenie baz danych.",
            "AutomatycznƒÖ normalizacjƒô."
        ],
        correct: 0,
        desc: "APPLY jest potƒô≈ºne ‚Äì pozwala przekazaƒá warto≈õƒá z lewej tabeli jako parametr do zapytania/funkcji po prawej stronie."
    },
    {
        q: "Wzorzec `LIKE '_a%'` pasuje do:",
        options: [
            "Tekstu, gdzie drugi znak to 'a' (np. 'Sala', 'Mama').",
            "Tekstu zaczynajƒÖcego siƒô na 'a'.",
            "Tekstu ko≈ÑczƒÖcego siƒô na 'a'.",
            "Tekstu 'a'."
        ],
        correct: 0,
        desc: "Podkre≈õlnik (_) zastƒôpuje dok≈Çadnie jeden znak, a procent (%) dowolny ciƒÖg. Zatem: jeden znak, potem 'a', potem reszta."
    },
    {
        q: "`INTERSECT` zwraca:",
        options: [
            "Czƒô≈õƒá wsp√≥lnƒÖ dw√≥ch zapyta≈Ñ (rekordy istniejƒÖce w obu).",
            "Sumƒô zapyta≈Ñ.",
            "R√≥≈ºnicƒô zapyta≈Ñ.",
            "Iloczyn zapyta≈Ñ."
        ],
        correct: 0,
        desc: "INTERSECT dzia≈Ça jak matematyczna czƒô≈õƒá wsp√≥lna zbior√≥w."
    },
    {
        q: "R√≥≈ºnica miƒôdzy `COUNT(*)` a `COUNT(kolumna)`:",
        options: [
            "COUNT(*) liczy wiersze (nawet z NULL), COUNT(kolumna) pomija NULLe w tej kolumnie.",
            "Brak r√≥≈ºnicy.",
            "COUNT(*) jest wolniejsze.",
            "COUNT(kolumna) liczy tylko unikalne."
        ],
        correct: 0,
        desc: "Je≈õli w kolumnie sƒÖ NULLe, COUNT(kolumna) zwr√≥ci mniejszy wynik ni≈º COUNT(*)."
    },
    {
        q: "`HAVING` s≈Çu≈ºy do filtrowania:",
        options: [
            "Grup po agregacji (np. suma > 1000).",
            "Pojedynczych wierszy przed grupowaniem.",
            "Tabel.",
            "Widok√≥w."
        ],
        correct: 0,
        desc: "HAVING to takie 'WHERE', ale dzia≈ÇajƒÖce na wynikach funkcji agregujƒÖcych (SUM, AVG, COUNT)."
    },
    {
        q: "`ROLLUP(a, b)` generuje grupy:",
        options: [
            "(a, b), (a) oraz podsumowanie og√≥lne ().",
            "Tylko (a, b).",
            "Wszystkie kombinacje (kostka).",
            "Losowe."
        ],
        correct: 0,
        desc: "ROLLUP idzie w g√≥rƒô hierarchii: Szczeg√≥≈Ç -> Og√≥≈Ç -> Ca≈Ço≈õƒá."
    },
    {
        q: "`GROUPING SETS` pozwala na:",
        options: [
            "Jawne wskazanie, kt√≥re konkretnie grupy chcemy policzyƒá (bez zbƒôdnych nadmiar√≥w).",
            "Automatyczne sortowanie.",
            "Tworzenie tabel przestawnych.",
            "Grupowanie tekstowe."
        ],
        correct: 0,
        desc: "To najbardziej elastyczna metoda grupowania. Definiujesz dok≈Çadnie te poziomy, kt√≥re Ciƒô interesujƒÖ."
    },
    {
        q: "Podzapytanie `WHERE x IN (...)` odpowiada:",
        options: [
            "WHERE x = ANY (...)",
            "WHERE x = ALL (...)",
            "WHERE x EXISTS (...)",
            "WHERE x LIKE (...)"
        ],
        correct: 0,
        desc: "IN sprawdza czy warto≈õƒá jest r√≥wna 'kt√≥remukolwiek' z element√≥w listy, co logicznie odpowiada = ANY."
    },
    {
        q: "Operator `> ALL` oznacza:",
        options: [
            "Wiƒôkszy od najwiƒôkszej warto≈õci w zbiorze (wiƒôkszy od wszystkich).",
            "Wiƒôkszy od najmniejszej.",
            "Wiƒôkszy od ≈õredniej.",
            "B≈ÇƒÖd sk≈Çadni."
        ],
        correct: 0,
        desc: "Je≈õli jeste≈õ lepszy ni≈º WSZYSCY zawodnicy, to znaczy, ≈ºe pobi≈Çe≈õ nawet mistrza (MAX)."
    },
    {
        q: "Poprawne sprawdzenie warto≈õci NULL to:",
        options: [
            "IS NULL",
            "= NULL",
            "!= NULL",
            "IS EMPTY"
        ],
        correct: 0,
        desc: "NULL to 'nieznana'. Nieznana nie jest r√≥wna nieznanej. Dlatego u≈ºywamy operatora IS."
    },
    {
        q: "`CAST` i `CONVERT` s≈Çu≈ºƒÖ do:",
        options: [
            "Zmiany typu danych (np. napis na liczbƒô).",
            "Szyfrowania.",
            "Kompresji.",
            "≈ÅƒÖczenia string√≥w."
        ],
        correct: 0,
        desc: "Obie funkcje rzutujƒÖ typy. CONVERT ma dodatkowe opcje formatowania (np. daty)."
    },
    {
        q: "Domy≈õlny poziom izolacji w SQL Server to:",
        options: [
            "READ COMMITTED",
            "SERIALIZABLE",
            "READ UNCOMMITTED",
            "REPEATABLE READ"
        ],
        correct: 0,
        desc: "Jest to kompromis miƒôdzy sp√≥jno≈õciƒÖ a wydajno≈õciƒÖ. Blokuje odczyt brudnych danych."
    },
    {
        q: "Klucz obcy (FK) zapewnia:",
        options: [
            "Integralno≈õƒá referencyjnƒÖ (sp√≥jno≈õƒá powiƒÖza≈Ñ miƒôdzy tabelami).",
            "Unikalno≈õƒá wierszy.",
            "Szybko≈õƒá zapyta≈Ñ.",
            "Szyfrowanie."
        ],
        correct: 0,
        desc: "FK pilnuje, by≈õ nie doda≈Ç zam√≥wienia dla nieistniejƒÖcego klienta."
    },
    {
        q: "Krotka (Tuple) w modelu relacyjnym to inaczej:",
        options: [
            "Wiersz (rekord).",
            "Kolumna.",
            "Tabela.",
            "Klucz."
        ],
        correct: 0,
        desc: "To formalna nazwa rekordu w teorii baz danych."
    },
    {
        q: "Klucz sztuczny (Surrogate Key) to:",
        options: [
            "Sztucznie dodany identyfikator (np. ID typu Integer), gdy brak klucza naturalnego.",
            "Klucz tymczasowy.",
            "Has≈Ço u≈ºytkownika.",
            "B≈ÇƒÖd projektowy."
        ],
        correct: 0,
        desc: "Czƒôsto u≈ºywamy `id INT IDENTITY`, bo naturalne klucze (np. nazwa firmy) mogƒÖ siƒô zmieniaƒá lub byƒá d≈Çugie."
    },
    {
        q: "`DELETE FROM tabela` (bez WHERE):",
        options: [
            "Usuwa wszystkie wiersze, operacja jest logowana.",
            "Usuwa tabelƒô z bazy.",
            "Nie zadzia≈Ça.",
            "Usuwa losowy wiersz."
        ],
        correct: 0,
        desc: "Czy≈õci dane, ale tabela zostaje. Jest to operacja DML (mo≈ºna cofnƒÖƒá)."
    },
    {
        q: "Relacja 1:1 jest u≈ºywana:",
        options: [
            "Rzadko, np. do wydzielenia danych poufnych lub rzadko u≈ºywanych (podzia≈Ç pionowy).",
            "Zawsze.",
            "Nigdy.",
            "Zamiast 1:N."
        ],
        correct: 0,
        desc: "Zazwyczaj dane trzymamy w jednej tabeli. 1:1 robimy, gdy np. opis produktu jest ogromny i rzadko czytany."
    },
    {
        q: "Samoz≈ÇƒÖczenie (Self-Join) stosujemy do:",
        options: [
            "Struktur hierarchicznych w jednej tabeli (np. pracownik - prze≈Ço≈ºony).",
            "≈ÅƒÖczenia dw√≥ch r√≥≈ºnych baz.",
            "Naprawy b≈Çƒôd√≥w.",
            "Usuwania duplikat√≥w."
        ],
        correct: 0,
        desc: "≈ÅƒÖczymy tabelƒô samƒÖ ze sobƒÖ, aby powiƒÖzaƒá rekordy wewnƒÖtrz niej."
    },
    {
        q: "Funkcja `GETDATE()` zwraca:",
        options: [
            "Bie≈ºƒÖcƒÖ datƒô i czas serwera.",
            "Datƒô urodzenia.",
            "Ostatni rekord.",
            "Czas u≈ºytkownika."
        ],
        correct: 0,
        desc: "Podstawowa funkcja w T-SQL do pobierania 'teraz'."
    },
    {
        q: "`CHECK constraint` s≈Çu≈ºy do:",
        options: [
            "Walidacji danych wg warunku logicznego (np. wiek > 0).",
            "Sprawdzania pisowni.",
            "≈ÅƒÖczenia tabel.",
            "Indeksowania."
        ],
        correct: 0,
        desc: "Zabezpiecza przed wpisaniem g≈Çupot, np. ujemnej ceny."
    },
    {
        q: "Instrukcja `MERGE` (Upsert):",
        options: [
            "Wstawia, aktualizuje lub usuwa dane w jednej operacji w zale≈ºno≈õci od dopasowania.",
            "≈ÅƒÖczy tabele w wynik.",
            "Tworzy widok.",
            "Kopiuje bazƒô."
        ],
        correct: 0,
        desc: "Bardzo przydatna przy synchronizacji danych: 'jak jest to zaktualizuj, jak nie ma to dodaj'."
    },
    {
        q: "`VARCHAR(50)` vs `CHAR(50)`:",
        options: [
            "VARCHAR ma zmiennƒÖ d≈Çugo≈õƒá (oszczƒôdza miejsce), CHAR sta≈ÇƒÖ (dope≈Çnia spacjami).",
            "Odwrotnie.",
            "To to samo.",
            "CHAR jest tylko do liczb."
        ],
        correct: 0,
        desc: "U≈ºywaj VARCHAR do nazwisk, a CHAR do kod√≥w o sta≈Çej d≈Çugo≈õci (np. kod pocztowy, PESEL)."
    },
    {
        q: "Aby pobraƒá 5 pierwszych wynik√≥w w T-SQL:",
        options: [
            "SELECT TOP 5 ...",
            "SELECT ... LIMIT 5",
            "SELECT ... WHERE ROWNUM < 5",
            "SELECT FIRST 5 ..."
        ],
        correct: 0,
        desc: "SQL Server u≈ºywa sk≈Çadni TOP. LIMIT jest popularny w MySQL/Postgres."
    },
    {
        q: "Wynik `10 + NULL` to:",
        options: [
            "NULL",
            "10",
            "0",
            "Error"
        ],
        correct: 0,
        desc: "NULL to czarna dziura. Cokolwiek do niej wrzucisz, wynik to NULL (nieznana)."
    },
    {
        q: "Sortowanie malejƒÖce to:",
        options: [
            "DESC",
            "ASC",
            "DOWN",
            "Z-A"
        ],
        correct: 0,
        desc: "DESC = Descending (w d√≥≈Ç)."
    },
    {
        q: "`UNION ALL` r√≥≈ºni siƒô od `UNION` tym, ≈ºe:",
        options: [
            "Nie usuwa duplikat√≥w (jest szybsze).",
            "Usuwa duplikaty.",
            "Sortuje wyniki.",
            "≈ÅƒÖczy kolumny poziomo."
        ],
        correct: 0,
        desc: "UNION musi posortowaƒá wyniki, ≈ºeby znale≈∫ƒá duplikaty i je usunƒÖƒá. UNION ALL po prostu skleja wyniki (szybciej)."
    },
    {
        q: "Widok (VIEW) to:",
        options: [
            "Zapisane zapytanie SELECT dzia≈ÇajƒÖce jak wirtualna tabela.",
            "Kopia zapasowa.",
            "Zrzut ekranu.",
            "Tabela tymczasowa."
        ],
        correct: 0,
        desc: "Widok nie trzyma danych (zazwyczaj), tylko definicjƒô jak je pobraƒá."
    },
    {
        q: "Trigger (Wyzwalacz) uruchamia siƒô:",
        options: [
            "Automatycznie po zdarzeniu (INSERT, UPDATE, DELETE).",
            "Na ≈ºƒÖdanie u≈ºytkownika.",
            "Raz dziennie.",
            "Tylko przy b≈Çƒôdach."
        ],
        correct: 0,
        desc: "Triggery s≈Çu≈ºƒÖ do automatyzacji logiki biznesowej lub audytu zmian."
    },
    {
        q: "Denormalizacja to:",
        options: [
            "Celowe wprowadzenie nadmiarowo≈õci dla wydajno≈õci odczytu.",
            "B≈ÇƒÖd w sztuce.",
            "Usuwanie tabel.",
            "Proces czyszczenia danych."
        ],
        correct: 0,
        desc: "Czasem warto powt√≥rzyƒá dane, ≈ºeby nie robiƒá 10 JOIN√≥w przy ka≈ºdym zapytaniu (np. w hurtowniach danych)."
    },
    {
        q: "Funkcja `COALESCE(a, b, c)` zwraca:",
        options: [
            "PierwszƒÖ warto≈õƒá niebƒôdƒÖcƒÖ NULLem.",
            "OstatniƒÖ warto≈õƒá.",
            "NajwiƒôkszƒÖ warto≈õƒá.",
            "Sumƒô warto≈õci."
        ],
        correct: 0,
        desc: "Bardzo przydatne do podstawiania warto≈õci domy≈õlnych, np. COALESCE(telefon, 'brak')."
    },
    {
        q: "4. Postaƒá Normalna (4NF) dotyczy:",
        options: [
            "Zale≈ºno≈õci wielowarto≈õciowych (niezale≈ºnych fakt√≥w w jednej tabeli).",
            "Zale≈ºno≈õci przechodnich.",
            "Kluczy obcych.",
            "Danych binarnych."
        ],
        correct: 0,
        desc: "Rozdziela niezale≈ºne fakty wielokrotne (np. pracownik zna jƒôzyki I pracownik ma dzieci - to powinny byƒá dwie osobne tabele)."
    },
    {
        q: "Jƒôzyk DCL (Data Control Language) zawiera:",
        options: [
            "GRANT, REVOKE, DENY",
            "SELECT, INSERT",
            "CREATE, DROP",
            "BEGIN, COMMIT"
        ],
        correct: 0,
        desc: "S≈Çu≈ºy do zarzƒÖdzania uprawnieniami (kto co mo≈ºe robiƒá)."
    },
    {
        q: "`LIKE '[A-C]%'` znajdzie:",
        options: [
            "Teksty zaczynajƒÖce siƒô na A, B lub C.",
            "Teksty zawierajƒÖce my≈õlnik.",
            "Tylko tekst 'ABC'.",
            "B≈ÇƒÖd sk≈Çadni."
        ],
        correct: 0,
        desc: "Nawiasy kwadratowe w LIKE definiujƒÖ zakres lub zbi√≥r znak√≥w."
    },
    {
        q: "Czym jest 'dirty page' w kontek≈õcie silnika bazy?",
        options: [
            "StronƒÖ pamiƒôci, kt√≥ra zosta≈Ça zmieniona, ale jeszcze nie zapisana na dysk.",
            "Uszkodzonym sektorem dysku.",
            "StronƒÖ z niecenzuralnƒÖ tre≈õciƒÖ.",
            "B≈Çƒôdem indeksu."
        ],
        correct: 0,
        desc: "Baza modyfikuje dane w RAMie (buffer pool). Dop√≥ki nie zrzuci ich na dysk (checkpoint), sƒÖ 'brudne'."
    }
];

// --- LOGIKA QUIZU ---
let currentQuestionIndex = 0;
let userAnswers = new Array(questions.length).fill(null);
let scoreCorrect = 0;
let scoreWrong = 0;

// Bezpieczne uruchamianie + MIESZANIE ODPOWIEDZI
window.onload = function() {
    try {
        if (!questions || questions.length === 0) {
            throw new Error("Brak pyta≈Ñ w bazie.");
        }
        
        // !!! MIESZANIE ODPOWIEDZI (SHUFFLE) !!!
        // Poni≈ºszy kod przemiesza kolejno≈õƒá przycisk√≥w, ale zachowa logikƒô kt√≥ra odpowied≈∫ jest dobra.
        questions.forEach(q => {
            // Zapisz tekst poprawnej odpowiedzi
            const correctText = q.options[q.correct];
            
            // Stw√≥rz nowƒÖ, losowƒÖ tablicƒô opcji
            // (Proste losowanie: sortuj wg losowej liczby)
            q.options.sort(() => Math.random() - 0.5);
            
            // Znajd≈∫ gdzie wylƒÖdowa≈Ça poprawna odpowied≈∫ i zaktualizuj indeks 'correct'
            q.correct = q.options.indexOf(correctText);
        });

        loadQuestion();
    } catch (e) {
        document.getElementById("question-text").innerText = "B≈ÇƒÖd krytyczny aplikacji: " + e.message;
    }
};

function loadQuestion() {
    const qData = questions[currentQuestionIndex];
    document.getElementById("question-text").innerText = `${currentQuestionIndex + 1}. ${qData.q}`;
    
    const optionsContainer = document.getElementById("options-container");
    optionsContainer.innerHTML = ""; // Czy≈õƒá stare

    qData.options.forEach((opt, index) => {
        const btn = document.createElement("button");
        btn.className = "option-btn";
        
        // Marker litery
        const letters = ["A", "B", "C", "D"];
        
        let content = `<span class="opt-letter">${letters[index]}</span> ${opt}`;
        
        // Stan po odpowiedzi
        if (userAnswers[currentQuestionIndex] !== null) {
            btn.disabled = true;
            if (index === qData.correct) {
                btn.classList.add("correct");
                // Dodaj ikonkƒô
                content += ' <span style="float:right">‚úÖ</span>';
            } else if (index === userAnswers[currentQuestionIndex]) {
                btn.classList.add("wrong");
                content += ' <span style="float:right">‚ùå</span>';
            }
        } else {
            // Klikalno≈õƒá tylko jak nie odpowiedziano
            btn.onclick = () => checkAnswer(index);
        }
        
        btn.innerHTML = content;
        optionsContainer.appendChild(btn);
    });

    // Wyja≈õnienie
    const explanationDiv = document.getElementById("explanation");
    if (userAnswers[currentQuestionIndex] !== null) {
        const isCorrect = userAnswers[currentQuestionIndex] === qData.correct;
        explanationDiv.innerHTML = `
            <div style="font-weight:bold; margin-bottom:5px; color:${isCorrect ? '#2ecc71' : '#ff5252'}">
                ${isCorrect ? "≈öwietnie!" : "Niestety ≈∫le."}
            </div>
            ${qData.desc}
        `;
        explanationDiv.className = `explanation visible ${isCorrect ? "success" : "error"}`;
    } else {
        explanationDiv.className = "explanation";
        explanationDiv.innerHTML = "";
    }

    // Pasek stanu
    document.getElementById("progress").innerText = `Pytanie ${currentQuestionIndex + 1} z ${questions.length}`;
    document.getElementById("prev-btn").disabled = currentQuestionIndex === 0;
    
    const nextBtn = document.getElementById("next-btn");
    nextBtn.disabled = false;
    if (currentQuestionIndex === questions.length - 1) {
        nextBtn.innerText = "Zako≈Ñcz Quiz";
        nextBtn.onclick = showSummary;
    } else {
        nextBtn.innerText = "Nastƒôpne";
        nextBtn.onclick = nextQuestion;
    }
}

function checkAnswer(selectedIndex) {
    if (userAnswers[currentQuestionIndex] !== null) return;

    userAnswers[currentQuestionIndex] = selectedIndex;
    const isCorrect = selectedIndex === questions[currentQuestionIndex].correct;

    if (isCorrect) scoreCorrect++;
    else scoreWrong++;

    updateScoreBoard();
    loadQuestion(); // Od≈õwie≈º widok (kolory)
}

function updateScoreBoard() {
    // Animacja licznika
    const cVal = document.getElementById("correct-count");
    const wVal = document.getElementById("wrong-count");
    
    cVal.innerText = scoreCorrect;
    wVal.innerText = scoreWrong;
}

function prevQuestion() {
    if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
        loadQuestion();
    }
}

function nextQuestion() {
    if (currentQuestionIndex < questions.length - 1) {
        currentQuestionIndex++;
        loadQuestion();
    }
}

function showSummary() {
    const container = document.getElementById("quiz-box");
    const percent = Math.round((scoreCorrect / questions.length) * 100);
    
    let msg = "";
    if (percent === 100) msg = "Perfekcja! Jeste≈õ mistrzem baz danych! üèÜ";
    else if (percent > 80) msg = "≈öwietny wynik! Bardzo dobrze znasz temat. ü•á";
    else if (percent > 50) msg = "Dobra robota, ale powt√≥rz trudniejsze tematy. üìö";
    else msg = "Musisz jeszcze trochƒô popracowaƒá nad teoriƒÖ. Nie poddawaj siƒô! üí™";

    let html = `
    <div class="summary-view">
        <h1 style="color:#fff; margin-bottom:10px;">Koniec Quizu!</h1>
        <div style="font-size:4em; font-weight:bold; color:${percent > 50 ? '#2ecc71' : '#ff5252'}">${percent}%</div>
        <p style="font-size:1.2em; color:#aaa; margin-bottom:30px;">${msg}</p>
        
        <div class="score-board" style="justify-content:center; margin-bottom:30px;">
            <div class="score-item score-correct" style="font-size:1.5em">‚úî ${scoreCorrect}</div>
            <div class="score-item score-wrong" style="font-size:1.5em; margin-left:20px;">‚úñ ${scoreWrong}</div>
        </div>

        <h3 style="text-align:left; border-bottom:1px solid #444; padding-bottom:10px;">Szczeg√≥≈Çowy raport:</h3>
        <div class="summary-list">`;

    questions.forEach((q, i) => {
        const ua = userAnswers[i];
        const isOk = ua === q.correct;
        const statusClass = isOk ? "good" : "bad";
        const statusIcon = isOk ? "‚úÖ" : (ua === null ? "‚ö™" : "‚ùå");
        
        html += `
        <div class="review-item ${statusClass}">
            <span class="review-q">${i+1}. ${q.q}</span>
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <span class="review-ans">Tw√≥j wyb√≥r: ${ua !== null ? q.options[ua] : "Pominiƒôto"}</span>
                <span style="font-size:1.2em">${statusIcon}</span>
            </div>
            ${!isOk ? `<div style="margin-top:5px; font-size:0.9em; color:#2ecc71">Poprawna: ${q.options[q.correct]}</div>` : ''}
        </div>`;
    });

    html += `</div>
        <button class="btn" onclick="location.reload()" style="margin-top:30px; width:100%; background-color:#444;">Zacznij od nowa</button>
    </div>`;
    
    container.innerHTML = html;
}
</script>

</body>
</html>
